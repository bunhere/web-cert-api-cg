<!DOCTYPE html>
<html>
<head>
	<meta content="text/html; charset=utf-8" http-equiv="content-type">
	<title>Web Certificate API</title>
	<script async class="remove" src=
	"https://www.w3.org/Tools/respec/respec-w3c-common">
	</script>
	<script class="remove">
	 var respecConfig = {
     //shortName:            "timing-entrytypes-registry",
	   specStatus:           "ED",
     // specStatus:           "WG-NOTE",
     noRecTrack: true,
     edDraftURI:  "https://github.com/w3c/web-cert-api-cg/blob/master/index.html",
     editors:  [
	{
	      "name": "이형욱(Hyungwook Lee)",
	      "company": "네이버(Naver)",
	      "url": "mailto:hyungwook.lee@navercorp.com",
	      "companyURL": "https://www.naver.com/",
	      "w3cid": 00000
    	},
	{
	      "name": "최병운",
	      "company": "네이버(Naver)",
	      "url": "mailto:ryuan.choi@navercorp.com",
	      "companyURL": "https://www.naver.com/",
	      "w3cid": 00000
    	},
	{
	      "name": "이원석(Wonsuk Lee)",
	      "company": "한국전자통신연구원(ETRI)",
	      "url": "mailto:wonsuk.lee@etri.re.kr",
	      "companyURL": "https://www.etri.re.kr/",
	      "w3cid": 34457
    	}	   
	     ],
	     wg: "Web Certificate API Community Group",
	     wgURI: "https://www.w3.org/community/web-cert-api/",
	     wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/53154/status",
	     github: {
				 repoURL: "https://github.com/w3c/web-cert-api-cg",
				 branch: "master"
			 },
	   };
	</script>
</head>
<body>
	<section id="abstract">
		<p>This specification defines a JavaScript API for certificate related operations in web applications, such as retrieving a list of certificates, obtaining a public key and a private key associated with a certificate.</p>
	</section>
	<section id="sotd">
	</section>
	<section id='introduction'>
		<h2>Introduction</h2>
		<p>The goal of Web Certificate API is to define a javaScript API for certificate related operations in web applications, such as retrieving a list of certificates, obtaining a public key and a private key associated with a certificate.</p>
	</section>
	<section id='conformance'>
	</section>
	<section id='web-certificate-interfaces'>
		<h2>Web Certificate Interfaces</h2>
		<p>The web API for certificate-based signing provides a certSign() method for the browser to accept the service provider's request and sign it with the user's private key.</p>
		<section id='example'>
			<h3>Example</h3>			
			<p>The example below signs a messageBuffer with the user's private key and verifies the message signed with the public key passed along with the signed message.</p>
			<pre class="example js" title="example code for web certificate api">
				var messageBuffer;

				// Fill messageBuffer in type of ArrayBuffer with data you want to sign.

				window.crypto.subtle.certSign(messageBuffer, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" }}, {"keyUsagses" : [ "nonRepudiation" ]})
				.then(signedObject => {
				// Do something with signedObject here
				      console.log(signedObject.certificate.publicKey);
				      console.log(buf2hex(signedObject.message));
				      return window.crypto.subtle.verify(
				      signedObject.certificate.publicKey.algorithm,
				      signedObject.certificate.publicKey,
				      signedObject.signedMessage,
				      signedObject.saltedMessage));
				    }).then(isValid => {
				      console.log(isValid);
				    });
				  })
				  .catch(error => {
				    // Handle exceptional case here
				    console.log(error.name + ":" + error.message);
				});
			</pre>
		</section>
		<section id='certsign-method'>
			<h3>certSign() Method</h3>
			<pre class="idl">
partial interface SubtleCrypto {
	Promise<SignedObject> certSign(BufferSource dataToSign, AlgorithmIdentifier algorithm, CertificateOptions options);
}; 
			</pre>
			<section id='certsign-method-description'>
				<h3>Description</h3>			
				<p>The certSign () method performs the digital signature using the private key of the certificate selected by the user among the certificates satisfying the options given as parameters, and returns the result to Promise. The browser needs to get confirmation from the user before responding to the API. The set of signing behaviors is the same as the sign () method of the Web Crypto API.</p>
			</section>
			<section id='certsign-method-parameters'>
				<h3>Parameters</h3>
				<section id='certsign-method-parameters-datatosign'>
					<h3>dataToSign</h3>
					<p>It contains the message to use for signing. The browser can use this signature with additional information, depending on whether the option is salted or not.</p>
				</section>
				<section id='certsign-method-parameters-algorithm'>
					<h3>Algorithm</h3>
					<p>It contains an information about the algorithm to use for signing.</p>					
				</section>
				<section id='certsign-method-parameters-options'>
					<h3>Options</h3>		
					<p>It contains additional information such as limiting available certificates for signing and processing the message.</p>					
				</section>					
			</section>
		</section>
		<section id='signedobject_interface'>
			<h3>SignedObject Interface</h3>		
			<pre class="idl">
Interface SignedObject {
    readonly attribute Certificate certificate;
    readonly attribute BufferSource saltedMessage; 
    readonly attribute BufferSource signedMessage;
} 
			</pre>
		</section>
		<section id='certificate_interface'>
			<h3>Certificate Interface</h3>			
			<p></p>
		</section>
		<section id='certificateprincipal_interface'>
			<h3>CertificatePrincipal Interface</h3>			
			<p></p>
		</section>
		<section id='certificaterequestoptions_dictionary'>
			<h3>CertificateRequestOptions dictionary</h3>			
			<p></p>
		</section>
		<section id='exceptions'>
			<h3>Exceptions</h3>			
			<p></p>			
		</section>		
	</section>
	<section id='privacy-and-security-considerations'>
		<h2>Privacy and Security Considerations</h2>
		<p>The web API for certificate-based signing handles the user's certificate and public / private key information, so the browser must pay special attention to security. This specification does not deal with spaces for storing user certificates and public / private keys, but browsers can exclude certificates and public / private keys that are not stored in secure storage. In addition, browsers can provide the ability for users to add, view, modify, or delete certificates and public / private keys used for web APIs for certificate-based signing, but are not covered in this specification.</p>
		<section id='user_agreements'>
			<h3>User agreements</h3>			
			<p>The browser must obtain explicit confirmation from the user to retrieve the certificate or to sign the certificate. At this time, the user's confirmation cannot be used from different origins on the same web page. If the user does not agree, a NotAllowedError exception is raised.</p>			
		</section>
		<section id='Man-in-the-middle-attack-and-domain-forgery'>
			<h3>Man-in-the-middle attack / domain forgery</h3>			
			<p>Browsers can sign host messages and browser information in a signature message to prevent man-in-the-middle attacks or domain forgery. Through this, even if the attacker delivers the signed message, the service provider can check whether the message is directly received from the user by using the host information included in the message.</p>			
		</section>		
	</section>	
</body>
</html>
